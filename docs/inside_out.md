# Inside_Out

원 궤도의 안팎으로 위치를 바꾸며 장애물을 피하는 게임

<br/>

## Index

- [2023.01.25.](#20230125)

<br/>

## 기획

> 학창 시절 좋아하던 [IMING](https://www.youtube.com/channel/UCc2mcayIGQVf1-AMo97VJ0w)의 [Orbit Or Beat](https://store.steampowered.com/app/1926550/Orbit_Or_Beat_Extended_Edition/?l=koreana) <sub><sup>_해당 링크는 원작이 아닌 리메이크된 작품_</sup></sub> 라는 게임을 구현해보고 싶어 만들게 된 게임.

<br/>

## 2023.01.25.

> 해당 게임은 원이라는 공간에서 이루어진다. [CircleEffector](./essential.md/#20230110)의 원으로 사용하면 좋겠다고 생각하였다.  
> 원의 크기는 윈도우 창의 높이와 너비 중 작은 값을 기준으로 정해진다. 이를 위해 CircleEffector의 크기가 너비와 높이의 최솟값으로 설정되도록 크기 조절 함수를 오버라이딩하였다.
>
> **Player.js**
> 플레이어 오브젝트는 원의 궤도를 공전한다. 원의 중심을 기준으로 캔버스의 각도를 돌려가며 그리는 방식으로, 추후 만들게 될 장애물 오브젝트와의 충돌을 각도의 값으로 계산할 예정이다.
> 마우스 클릭 시마다 reversed라는 bool변수가 true/false 전환이 되며 플레이어 오브젝트의 위치 및 색상을 변경하여 드로우한다.
>
> **Spikes.js**
> 이 게임은 장애물의 갯수 및 위치가 변하지 않고 플레이어의 속도만 바뀐다.  
> 그에 따라 이번에는 가시 각각의 클래스를 불러와 게임 호출 메소드에서 배열을 생성하여 넣어쓰는 기존의 방식과는 다르게 '가시들'이라는 장애물의 집합 클래스를 사용하여 보았다.  
> 가시는 삼각형으로 그려진다. 가시가 작기 때문에 그냥 삼각형으로 그렸어도 티가 나지 않았겠지만, 완벽함을 위하여 원의 현을 이용하여 원의 테두리에 알맞은 삼각형(피자와 같은 형태)을 그리도록 프로그래밍하였다.
>
> ```
> for(let i=0; i<360; i+=ANGLE){
>     this.ctx.beginPath();
>     this.ctx.arc(0, 0, this.area/2.5, (-90-this.size/10)/180*Math.PI, (-90+this.size/10)/180*Math.PI);
>     this.ctx.lineTo(0,-this.area/2.5 + (this.size * ((this.reversed)?1:-1)));
>     this.ctx.fill();
>     this.ctx.rotate(ANGLE/180*Math.PI);
> }
> ```
>
> **문제**
>
> > 플레이어가 원을 한 바퀴 돌고 나면 충돌을 정상적으로 확인하지 못 하는 오류가 있었다.
>
> **해결**
>
> > 이는 플레이어가 360도일 때와 가시가 0도일 때, 즉 실질적인 값이 다르기에 생기는 간단한 문제였다.  
> > 플레이어의 각도값이 360도가 넘어가면 360을 빼주었다.
>
> **문제**
>
> > 플레이어 오브젝트와 가시가 정반대에 있을 때, 즉 각도값의 차이의 절댓값이 180이 될 때, 가시의 방향을 50%확률로 변경한다.
> > 이는 플레이어 오브젝트의 각도가 180의 약수로만 움직여야 한다는 것을 의미한다.
>
> **해결**
>
> > 플레이어 오브젝트의 현재 각도와 다음 각도를 인수로 받아 각 가시의 각도와 현재 각도의 차이가 180이하이고 다음 각도와의 차이가 180을 초과할 때를 확인한다.
> > 이때,
> >
> > ```
> > if((current_angle<=angle+180 && next_angle>angle+180) || (current_angle<=angle-180 && next_angle>angle-180))
> > ```
> >
> > 가시의 충돌 또한 이와 같은 방식으로 확인하도록 하였다.
> >
> > ```
> > if((current_angle<=angle && next_angle>angle) && spikes[i]==reversed)
> > ```
>
> 가시들을 그릴 때 단순히 캔버스의 너비,높이의 최솟값을 기준으로 그려버린다면, CircleEffector의 화면 전환 애니메이션 중 어색함이 발생한다.  
> 이에 따라 CircleEffector의 크기를 직접 가져오는 메소드를 추가하여 적용하였다. [[자세히]](./essential.md#20230125)
>
> 플레이어가 원을 한 바퀴 돌 떄마다 점수를 추가하며, 회전 속도가 점점 증가한다.  
> 최대 속도에는 제한을 두었다.
